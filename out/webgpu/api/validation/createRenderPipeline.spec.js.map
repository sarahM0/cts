{"version":3,"sources":["../../../../src/webgpu/api/validation/createRenderPipeline.spec.ts"],"names":["description","poptions","makeTestGroup","kAllTextureFormats","kAllTextureFormatInfo","ValidationTest","F","getDescriptor","options","defaultColorStates","format","primitiveTopology","colorStates","sampleCount","depthStencilState","length","fragColorType","suffix","endsWith","vertexStage","module","device","createShaderModule","code","entryPoint","fragmentStage","layout","getPipelineLayout","createPipelineLayout","bindGroupLayouts","createTexture","params","size","width","height","depth","usage","GPUTextureUsage","OUTPUT_ATTACHMENT","g","test","fn","t","descriptor","createRenderPipeline","goodDescriptor","badDescriptor","expectValidationError","info","renderable","color","_success","attachmentSamples","pipelineSamples","colorTexture","depthStencilTexture","renderPassDescriptorWithoutDepthStencil","colorAttachments","attachment","createView","loadValue","r","b","a","renderPassDescriptorWithDepthStencilOnly","depthStencilAttachment","depthLoadValue","depthStoreOp","stencilLoadValue","stencilStoreOp","pipelineWithoutDepthStencil","pipelineWithDepthStencilOnly","renderPassDescriptor","pipeline","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","setPipeline","endPass","finish"],"mappings":"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","sourcesContent":["export const description = `\ncreateRenderPipeline validation tests.\n\nTODO: review existing tests, write descriptions, and make sure tests are complete.\n      Make sure the following is covered. Consider splitting the file if too large/disjointed.\n> - various attachment problems\n>\n> - interface matching between vertex and fragment shader\n>     - superset, subset, etc.\n>\n> - vertexStage {valid, invalid}\n> - fragmentStage {valid, invalid}\n> - primitiveTopology all possible values\n> - rasterizationState various values\n> - sampleCount {0, 1, 3, 4, 8, 16, 1024}\n> - sampleMask {0, 0xFFFFFFFF}\n> - alphaToCoverage:\n>     - alphaToCoverageEnabled is { true, false } and sampleCount { = 1, = 4 }.\n>       The only failing case is (true, 1).\n>     - output SV_Coverage semantics is statically used by fragmentStage and\n>       alphaToCoverageEnabled is { true (fails), false (passes) }.\n>     - sampleMask is being used and alphaToCoverageEnabled is { true (fails), false (passes) }.\n\n`;\n\nimport { poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { kAllTextureFormats, kAllTextureFormatInfo } from '../../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nclass F extends ValidationTest {\n  getDescriptor(\n    options: {\n      primitiveTopology?: GPUPrimitiveTopology;\n      colorStates?: GPUColorStateDescriptor[];\n      sampleCount?: number;\n      depthStencilState?: GPUDepthStencilStateDescriptor;\n    } = {}\n  ): GPURenderPipelineDescriptor {\n    const defaultColorStates: GPUColorStateDescriptor[] = [{ format: 'rgba8unorm' }];\n    const {\n      primitiveTopology = 'triangle-list',\n      colorStates = defaultColorStates,\n      sampleCount = 1,\n      depthStencilState,\n    } = options;\n\n    const format = colorStates.length ? colorStates[0].format : 'rgba8unorm';\n\n    let fragColorType;\n    let suffix;\n    if (format.endsWith('sint')) {\n      fragColorType = 'i32';\n      suffix = '';\n    } else if (format.endsWith('uint')) {\n      fragColorType = 'u32';\n      suffix = 'u';\n    } else {\n      fragColorType = 'f32';\n      suffix = '.0';\n    }\n\n    return {\n      vertexStage: {\n        module: this.device.createShaderModule({\n          code: `\n            [[builtin(position)]] var<out> Position : vec4<f32>;\n\n            [[stage(vertex)]] fn main() -> void {\n              Position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: this.device.createShaderModule({\n          code: `\n            [[location(0)]] var<out> fragColor : vec4<${fragColorType}>;\n            [[stage(fragment)]] fn main() -> void {\n              fragColor = vec4<${fragColorType}>(0${suffix}, 1${suffix}, 0${suffix}, 1${suffix});\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      layout: this.getPipelineLayout(),\n      primitiveTopology,\n      colorStates,\n      sampleCount,\n      depthStencilState,\n    };\n  }\n\n  getPipelineLayout(): GPUPipelineLayout {\n    return this.device.createPipelineLayout({ bindGroupLayouts: [] });\n  }\n\n  createTexture(params: { format: GPUTextureFormat; sampleCount: number }): GPUTexture {\n    const { format, sampleCount } = params;\n\n    return this.device.createTexture({\n      size: { width: 4, height: 4, depth: 1 },\n      usage: GPUTextureUsage.OUTPUT_ATTACHMENT,\n      format,\n      sampleCount,\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic_use_of_createRenderPipeline').fn(t => {\n  const descriptor = t.getDescriptor();\n\n  t.device.createRenderPipeline(descriptor);\n});\n\ng.test('at_least_one_color_state_is_required').fn(async t => {\n  const goodDescriptor = t.getDescriptor({\n    colorStates: [{ format: 'rgba8unorm' }],\n  });\n\n  // Control case\n  t.device.createRenderPipeline(goodDescriptor);\n\n  // Fail because lack of color states\n  const badDescriptor = t.getDescriptor({\n    colorStates: [],\n  });\n\n  t.expectValidationError(() => {\n    t.device.createRenderPipeline(badDescriptor);\n  });\n});\n\ng.test('color_formats_must_be_renderable')\n  .params(poptions('format', kAllTextureFormats))\n  .fn(async t => {\n    const format: GPUTextureFormat = t.params.format;\n    const info = kAllTextureFormatInfo[format];\n\n    const descriptor = t.getDescriptor({ colorStates: [{ format }] });\n\n    if (info.renderable && info.color) {\n      // Succeeds when color format is renderable\n      t.device.createRenderPipeline(descriptor);\n    } else {\n      // Fails because when format is non-renderable\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n  });\n\ng.test('sample_count_must_be_valid')\n  .params([\n    { sampleCount: 0, _success: false },\n    { sampleCount: 1, _success: true },\n    { sampleCount: 2, _success: false },\n    { sampleCount: 3, _success: false },\n    { sampleCount: 4, _success: true },\n    { sampleCount: 8, _success: false },\n    { sampleCount: 16, _success: false },\n  ])\n  .fn(async t => {\n    const { sampleCount, _success } = t.params;\n\n    const descriptor = t.getDescriptor({ sampleCount });\n\n    if (_success) {\n      // Succeeds when sample count is valid\n      t.device.createRenderPipeline(descriptor);\n    } else {\n      // Fails when sample count is not 4 or 1\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n  });\n\ng.test('sample_count_must_be_equal_to_the_one_of_every_attachment_in_the_render_pass')\n  .params([\n    { attachmentSamples: 4, pipelineSamples: 4, _success: true }, // It is allowed to use multisampled render pass and multisampled render pipeline.\n    { attachmentSamples: 4, pipelineSamples: 1, _success: false }, // It is not allowed to use multisampled render pass and non-multisampled render pipeline.\n    { attachmentSamples: 1, pipelineSamples: 4, _success: false }, // It is not allowed to use non-multisampled render pass and multisampled render pipeline.\n  ])\n  .fn(async t => {\n    const { attachmentSamples, pipelineSamples, _success } = t.params;\n\n    const colorTexture = t.createTexture({\n      format: 'rgba8unorm',\n      sampleCount: attachmentSamples,\n    });\n    const depthStencilTexture = t.createTexture({\n      format: 'depth24plus-stencil8',\n      sampleCount: attachmentSamples,\n    });\n    const renderPassDescriptorWithoutDepthStencil = {\n      colorAttachments: [\n        {\n          attachment: colorTexture.createView(),\n          loadValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n        },\n      ],\n    };\n    const renderPassDescriptorWithDepthStencilOnly = {\n      colorAttachments: [],\n      depthStencilAttachment: {\n        attachment: depthStencilTexture.createView(),\n        depthLoadValue: 1.0,\n        depthStoreOp: 'store',\n        stencilLoadValue: 0,\n        stencilStoreOp: 'store',\n      },\n    };\n\n    const pipelineWithoutDepthStencil = t.device.createRenderPipeline(\n      t.getDescriptor({\n        sampleCount: pipelineSamples,\n      })\n    );\n    const pipelineWithDepthStencilOnly = t.device.createRenderPipeline(\n      t.getDescriptor({\n        colorStates: [],\n        depthStencilState: { format: 'depth24plus-stencil8' },\n        sampleCount: pipelineSamples,\n      })\n    );\n\n    for (const { renderPassDescriptor, pipeline } of [\n      {\n        renderPassDescriptor: renderPassDescriptorWithoutDepthStencil,\n        pipeline: pipelineWithoutDepthStencil,\n      },\n      {\n        renderPassDescriptor: renderPassDescriptorWithDepthStencilOnly,\n        pipeline: pipelineWithDepthStencilOnly,\n      },\n    ]) {\n      const commandEncoder = t.device.createCommandEncoder();\n      const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);\n      renderPass.setPipeline(pipeline);\n      renderPass.endPass();\n\n      t.expectValidationError(() => {\n        commandEncoder.finish();\n      }, !_success);\n    }\n  });\n"],"file":"createRenderPipeline.spec.js"}
{"version":3,"sources":["../../../../../../src/webgpu/api/validation/encoding/programmable/pipeline_bind_group_compat.spec.ts"],"names":["description","makeTestGroup","ValidationTest","F","getUniformBuffer","device","createBuffer","size","Float32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","UNIFORM","createRenderPipeline","pipeline","vertexStage","module","createShaderModule","code","entryPoint","fragmentStage","primitiveTopology","colorStates","format","beginRenderPass","commandEncoder","attachmentTexture","createTexture","width","height","depth","GPUTextureUsage","OUTPUT_ATTACHMENT","colorAttachments","attachment","createView","loadValue","r","g","b","a","test","params","setBindGroup1","setBindGroup2","_success","fn","t","uniformBuffer","bindGroup0","createBindGroup","entries","binding","resource","buffer","layout","getBindGroupLayout","bindGroup1","createCommandEncoder","renderPass","setPipeline","setBindGroup","draw","endPass","expectValidationError","finish"],"mappings":"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","sourcesContent":["export const description = `\nTODO:\n- test compatibility between bind groups and pipelines\n    - bind groups required by the pipeline layout are required.\n    - bind groups unused by the pipeline layout can be set or not.\n        (Even if e.g. bind groups 0 and 2 are used, but 1 is unused.)\n    - bindGroups[i].layout is \"group-equivalent\" (value-equal) to pipelineLayout.bgls[i].\n    - in the test fn, test once without the dispatch/draw (should always be valid) and once with\n      the dispatch/draw, to make sure the validation happens in dispatch/draw.\n    - x= {dispatch, all draws} (dispatch/draw should be size 0 to make sure validation still happens if no-op)\n    - x= all relevant stages\n\nTODO: subsume existing test, rewrite fixture as needed.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nclass F extends ValidationTest {\n  getUniformBuffer(): GPUBuffer {\n    return this.device.createBuffer({\n      size: 8 * Float32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n  }\n\n  createRenderPipeline(): GPURenderPipeline {\n    const pipeline = this.device.createRenderPipeline({\n      vertexStage: {\n        module: this.device.createShaderModule({\n          code: `\n            [[block]] struct VertexUniforms {\n              [[offset(0)]] transform : mat2x2<f32> ;\n            };\n            [[group(0), binding(0)]] var<uniform> uniforms : VertexUniforms;\n\n            [[builtin(position)]] var<out> Position : vec4<f32>;\n            [[builtin(vertex_index)]] var<in> VertexIndex : i32;\n            [[stage(vertex)]] fn main() -> void {\n              var pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>( 1.0, -1.0),\n                vec2<f32>(-1.0,  1.0)\n              );\n              Position = vec4<f32>(uniforms.transform * pos[VertexIndex], 0.0, 1.0);\n              return;\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: this.device.createShaderModule({\n          code: `\n            [[block]] struct FragmentUniforms {\n              [[offset(0)]] color : vec4<f32>;\n            };\n            [[group(1), binding(0)]] var<uniform> uniforms : FragmentUniforms;\n\n            [[location(0)]] var<out> fragColor : vec4<f32>;\n            [[stage(fragment)]] fn main() -> void {\n              fragColor = uniforms.color;\n              return;\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      primitiveTopology: 'triangle-list',\n      colorStates: [{ format: 'rgba8unorm' }],\n    });\n    return pipeline;\n  }\n\n  beginRenderPass(commandEncoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const attachmentTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 16, height: 16, depth: 1 },\n      usage: GPUTextureUsage.OUTPUT_ATTACHMENT,\n    });\n\n    return commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          attachment: attachmentTexture.createView(),\n          loadValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n        },\n      ],\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('it_is_invalid_to_draw_in_a_render_pass_with_missing_bind_groups')\n  .params([\n    { setBindGroup1: true, setBindGroup2: true, _success: true },\n    { setBindGroup1: true, setBindGroup2: false, _success: false },\n    { setBindGroup1: false, setBindGroup2: true, _success: false },\n    { setBindGroup1: false, setBindGroup2: false, _success: false },\n  ])\n  .fn(async t => {\n    const { setBindGroup1, setBindGroup2, _success } = t.params;\n\n    const pipeline = t.createRenderPipeline();\n\n    const uniformBuffer = t.getUniformBuffer();\n\n    const bindGroup0 = t.device.createBindGroup({\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n      layout: pipeline.getBindGroupLayout(0),\n    });\n\n    const bindGroup1 = t.device.createBindGroup({\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n      layout: pipeline.getBindGroupLayout(1),\n    });\n\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = t.beginRenderPass(commandEncoder);\n    renderPass.setPipeline(pipeline);\n    if (setBindGroup1) {\n      renderPass.setBindGroup(0, bindGroup0);\n    }\n    if (setBindGroup2) {\n      renderPass.setBindGroup(1, bindGroup1);\n    }\n    renderPass.draw(3);\n    renderPass.endPass();\n    t.expectValidationError(() => {\n      commandEncoder.finish();\n    }, !_success);\n  });\n"],"file":"pipeline_bind_group_compat.spec.js"}
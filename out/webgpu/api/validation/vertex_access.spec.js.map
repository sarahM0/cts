{"version":3,"sources":["../../../../src/webgpu/api/validation/vertex_access.spec.ts"],"names":["description","makeTestGroup","ValidationTest","g"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CApFO,CAsFP,SAASC,aAAT,QAA8B,yCAA9B;;AAEA,SAASC,cAAT,QAA+B,sBAA/B;;AAEA,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,cAAD,CAAvB","sourcesContent":["export const description = `\nTODO: make sure this isn't already covered somewhere else, review, organize, and implement.\n> - In encoder.finish():\n>     - setVertexBuffer and setIndexBuffer commands (even if no draw):\n>         - If not valid at draw time, test overlapping {vertex/vertex,vertex/index}\n>           buffers are valid without draw.\n>         - Before, after setPipeline (should have no effect)\n>         - Implicit offset/size are computed correctly. E.g.:\n>             { offset:         0, boundSize:         0, bufferSize: 24 },\n>             { offset:         0, boundSize: undefined, bufferSize: 24 },\n>             { offset: undefined, boundSize:         0, bufferSize: 24 },\n>             { offset: undefined, boundSize: undefined, bufferSize: 24 },\n>             { offset:         8, boundSize:        16, bufferSize: 24 },\n>             { offset:         8, boundSize: undefined, bufferSize: 24 },\n>         - Computed {index, vertex} buffer size is zero.\n>             (Omit draw command if it's not necessary to trigger error, otherwise test both with and without draw command to make sure error happens at the right time.)\n>             { offset: 24, boundSize: undefined, bufferSize: 24, _ok: false },\n>         - Bound range out-of-bounds on the GPUBuffer. E.g.:\n>             - x= offset in {0,8}\n>             - x= boundSize in {8,16,17}\n>             - x= extraSpaceInBuffer in {-1,0}\n>     - All (non/indexed, in/direct) draw commands\n>         - Same GPUBuffer bound to multiple vertex buffer slots\n>             - Non-overlapping, overlapping ranges\n>         - A needed vertex buffer is not bound\n>             - Was bound in another render pass but not the current one\n>             - x= all vertex formats\n>         - setPl, setVB, setIB, draw, {setPl,setVB,setIB,nothing (control)}, then\n>           a larger draw that wouldn't have been valid before that\n>         - Draw call needs to read {=, >} any bound vertex buffer range\n>           (with GPUBuffer that is always large enough)\n>             - x= all vertex formats\n>             - x= weird offset values\n>             - x= weird arrayStride values\n>         - A bound vertex buffer range is significantly larger than necessary\n>     - All non-indexed (in/direct) draw commands, {\n>         - An unused {index (with uselessly small range), vertex} buffer\n>           is bound (immediately before draw call)\n>         - }\n>     - All indexed (in/direct) draw commands, {\n>         - No index buffer is bound\n>         - Same GPUBuffer bound to index buffer and a vertex buffer slot\n>             - Non-overlapping, overlapping ranges\n>         - Draw call needs to read {=, >} the bound index buffer range\n>           (with GPUBuffer that is always large enough)\n>             - range is too small and GPUBuffer is large enough\n>             - range and GPUBuffer are exact size\n>             - x= all index formats\n>         - Bound index buffer range is significantly larger than necessary\n>         - }\n>     - Alignment constraints on setVertexBuffer if any\n>     - Alignment constraints on setIndexBuffer if any\n> - In queue.submit():\n>     - Indexed draw call with index buffer containing:\n>         - Index value that goes out-of-bounds on a bound vertex buffer range\n>         - Index value that is extremely large (but not the primitive restart value)\n>     - Line strip or triangle strip with index buffer containing:\n>         - Primitive restart value\n>         - Primitive restart value minus one (and the bound vertex buffers are < that size)\n>     - Indirect draw call with arguments that:\n>         - Go out-of-bounds on the bound index buffer range\n>         - Go out-of-bounds on the bound vertex buffer range\n\nTODO: Had two plans with roughly the same name. Figure out where to categorize these notes:\n> All x= {render pass, render bundle}\n>\n> - non-indexed draws:\n>     - vertex access out of bounds (make sure this doesn't overlap with robust access)\n>         - bound vertex buffer **ranges** are {exact size, just under exact size} needed for draws with:\n>             - vertexCount largeish\n>             - firstVertex {=, >} 0\n>             - instanceCount largeish\n>             - firstInstance {=, >} 0\n>         - include VBs with both step modes\n>     - x= {draw, drawIndirect}\n> - indexed draws:\n>     - vertex access out of bounds (make sure this doesn't overlap with robust access)\n>         - bound vertex buffer **ranges** are {exact size, just under exact size} needed for draws with:\n>             - a vertex index in the buffer is largeish\n>             - baseVertex {=, >} 0\n>             - instanceCount largeish\n>             - firstInstance {=, >} 0\n>         - include VBs with both step modes\n>     - x= {drawIndirect, drawIndexedIndirect}\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nexport const g = makeTestGroup(ValidationTest);\n"],"file":"vertex_access.spec.js"}
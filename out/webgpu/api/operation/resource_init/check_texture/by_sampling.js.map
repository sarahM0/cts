{"version":3,"sources":["../../../../../../src/webgpu/api/operation/resource_init/check_texture/by_sampling.ts"],"names":["assert","kEncodableTextureFormatInfo","kTexelRepresentationInfo","getSingleDataType","getComponentReadbackTraits","checkContentsBySampling","t","params","texture","state","subresourceRange","dimension","format","rep","level","slices","mipLevels","width","textureWidth","height","textureHeight","ReadbackTypedArray","shaderType","componentOrder","componentCount","length","indexExpression","toLowerCase","map","c","join","_xd","_multisampled","sampleCount","computePipeline","device","createComputePipeline","computeStage","entryPoint","module","createShaderModule","code","slice","ubo","createBuffer","mappedAtCreation","size","usage","GPUBufferUsage","UNIFORM","COPY_DST","Int32Array","getMappedRange","unmap","byteLength","BYTES_PER_ELEMENT","resultBuffer","STORAGE","COPY_SRC","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","buffer","createView","baseMipLevel","mipLevelCount","baseArrayLayer","arrayLayerCount","commandEncoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","queue","submit","finish","destroy","expectedValues","ArrayBuffer","expectedState","stateToTexelComponents","i","h","w","value","undefined","expectContents"],"mappings":"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","sourcesContent":["import { assert } from '../../../../../common/framework/util/util.js';\nimport {\n  EncodableTextureFormat,\n  kEncodableTextureFormatInfo,\n} from '../../../../capability_info.js';\nimport {\n  kTexelRepresentationInfo,\n  getSingleDataType,\n  getComponentReadbackTraits,\n} from '../../../../util/texture/texel_data.js';\nimport { CheckContents } from '../texture_zero.spec.js';\n\nexport const checkContentsBySampling: CheckContents = (\n  t,\n  params,\n  texture,\n  state,\n  subresourceRange\n) => {\n  assert(params.dimension === '2d');\n  assert(params.format in kEncodableTextureFormatInfo);\n  const format = params.format as EncodableTextureFormat;\n  const rep = kTexelRepresentationInfo[format];\n\n  for (const { level, slices } of subresourceRange.mipLevels()) {\n    const width = t.textureWidth >> level;\n    const height = t.textureHeight >> level;\n\n    const { ReadbackTypedArray, shaderType } = getComponentReadbackTraits(\n      getSingleDataType(format)\n    );\n\n    const componentOrder = rep.componentOrder;\n    const componentCount = componentOrder.length;\n\n    // For single-component textures, generates .r\n    // For multi-component textures, generates ex.)\n    //  .rgba[i], .bgra[i], .rgb[i]\n    const indexExpression =\n      componentCount === 1\n        ? componentOrder[0].toLowerCase()\n        : componentOrder.map(c => c.toLowerCase()).join('') + '[i]';\n\n    const _xd = '_' + params.dimension;\n    const _multisampled = params.sampleCount > 1 ? '_multisampled' : '';\n    const computePipeline = t.device.createComputePipeline({\n      computeStage: {\n        entryPoint: 'main',\n        module: t.device.createShaderModule({\n          code: `\n            [[block]] struct Constants {\n              [[offset(0)]] level : i32;\n            };\n\n            [[group(0), binding(0)]] var<uniform> constants : Constants;\n            [[group(0), binding(1)]] var<uniform_constant> myTexture : texture${_multisampled}${_xd}<${shaderType}>;\n\n            [[block]] struct Result {\n              [[offset(0)]] values : [[stride(4)]] array<${shaderType}>;\n            };\n            [[group(0), binding(3)]] var<storage_buffer> result : Result;\n\n            [[builtin(global_invocation_id)]] var<in> GlobalInvocationID : vec3<u32>;\n\n            [[stage(compute)]]\n            fn main() -> void {\n              var flatIndex : u32 = ${width}u * GlobalInvocationID.y + GlobalInvocationID.x;\n              flatIndex = flatIndex * ${componentCount}u;\n              var texel : vec4<${shaderType}> = textureLoad(\n                myTexture, vec2<i32>(GlobalInvocationID.xy), constants.level);\n\n              for (var i : u32 = flatIndex; i < flatIndex + ${componentCount}u; i = i + 1) {\n                result.values[i] = texel.${indexExpression};\n              }\n              return;\n            }`,\n        }),\n      },\n    });\n\n    for (const slice of slices) {\n      const ubo = t.device.createBuffer({\n        mappedAtCreation: true,\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      });\n      new Int32Array(ubo.getMappedRange(), 0, 1)[0] = level;\n      ubo.unmap();\n\n      const byteLength =\n        width * height * ReadbackTypedArray.BYTES_PER_ELEMENT * rep.componentOrder.length;\n      const resultBuffer = t.device.createBuffer({\n        size: byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      });\n\n      const bindGroup = t.device.createBindGroup({\n        layout: computePipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: { buffer: ubo },\n          },\n          {\n            binding: 1,\n            resource: texture.createView({\n              baseMipLevel: 0,\n              mipLevelCount: params.mipLevelCount,\n              baseArrayLayer: slice,\n              arrayLayerCount: 1,\n            }),\n          },\n          {\n            binding: 3,\n            resource: {\n              buffer: resultBuffer,\n            },\n          },\n        ],\n      });\n\n      const commandEncoder = t.device.createCommandEncoder();\n      const pass = commandEncoder.beginComputePass();\n      pass.setPipeline(computePipeline);\n      pass.setBindGroup(0, bindGroup);\n      pass.dispatch(width, height);\n      pass.endPass();\n      t.queue.submit([commandEncoder.finish()]);\n      ubo.destroy();\n\n      const expectedValues = new ReadbackTypedArray(new ArrayBuffer(byteLength));\n      const expectedState = t.stateToTexelComponents[state];\n      let i = 0;\n      for (let h = 0; h < height; ++h) {\n        for (let w = 0; w < height; ++w) {\n          for (const c of rep.componentOrder) {\n            const value = expectedState[c];\n            assert(value !== undefined);\n            expectedValues[i++] = value;\n          }\n        }\n      }\n      t.expectContents(resultBuffer, expectedValues);\n    }\n  }\n};\n"],"file":"by_sampling.js"}
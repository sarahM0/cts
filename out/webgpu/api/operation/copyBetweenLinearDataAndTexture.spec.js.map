{"version":3,"sources":["../../../../src/webgpu/api/operation/copyBetweenLinearDataAndTexture.spec.ts"],"names":["description","params","poptions","makeTestGroup","assert","unreachable","kSizedTextureFormatInfo","kSizedTextureFormats","GPUTest","align","getTextureCopyLayout","kMethodsToTest","initMethod","checkMethod","CopyBetweenLinearDataAndTextureTest","bytesInACompleteRow","copyWidth","format","blockWidth","copyWidthInBlocks","bytesPerBlock","requiredBytesInCopy","layout","copyExtent","rowsPerImage","blockHeight","height","width","depth","texelBlockRowsPerImage","bytesPerImage","bytesPerRow","bytesInLastSlice","getTexelOffsetInBytes","textureDataLayout","texel","origin","x","y","z","offset","info","iterateBlockRows","size","generateData","byteSize","start","arr","Uint8Array","i","undefDataLayoutIfNeeded","changeBeforePass","undefined","undefOrArrayCopyViewIfNeeded","texture","origin_x","origin_y","origin_z","mipLevel","arrayCopySizeIfNeeded","copyTextureToBufferWithAppliedArguments","buffer","appliedCopyView","appliedDataLayout","appliedCheckSize","encoder","device","createCommandEncoder","copyTextureToBuffer","defaultQueue","submit","finish","uploadLinearTextureDataToTextureSubBox","textureCopyView","copySize","partialData","method","appliedCopySize","writeTexture","createBuffer","mappedAtCreation","byteLength","usage","GPUBufferUsage","COPY_SRC","getMappedRange","set","unmap","copyBufferToTexture","copyPartialTextureToBufferAndCheckContents","checkSize","expected","expectedDataLayout","bufferSize","bufferData","COPY_DST","updateLinearTextureDataSubBox","expectContents","copyWholeTextureToNewBuffer","resultDataLayout","mipSize","copyFromArrayToArray","src","srcOffset","dst","dstOffset","subarray","sourceDataLayout","destination","source","sourceOffset","destinationOffset","rowLength","copyWholeTextureToBufferAndCheckContentsWithUpdatedData","fullTextureCopyLayout","texturePartialDataLayout","fullData","begin","end","createAlignedCopyForMapRead","eventualAsyncExpectation","mapAsync","GPUMapMode","READ","actual","destroy","uploadTextureAndVerifyCopy","dataSize","textureSize","dimension","createTexture","mipLevelCount","GPUTextureUsage","data","formatCanBeTested","copyDst","copySrc","g","test","combine","bytesPerRowPadding","rowsPerImagePaddingInBlocks","copyHeightInBlocks","copyDepth","filter","fn","t","bytesPerRowAlignment","copyHeight","minDataSize","Math","max","offsetInBlocks","dataPaddingInBytes","unless","p","copySizeValueInBlocks","originValueInBlocks","textureSizePaddingValueInBlocks","coordinateToTest","textureSizeExpander","_texturePhysicalSizeAtMipLevelInBlocks","widthAtThisLevel","heightAtThisLevel","widthAtPrevLevel","heightAtPrevLevel","modifiedWidth","modifiedHeight","modifyWidth","modifyHeight","copySizeInBlocks","originInBlocks","expand"],"mappings":"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","sourcesContent":["export const description = `writeTexture + copyBufferToTexture + copyTextureToBuffer operation tests.\n\n* copy_with_various_rows_per_image_and_bytes_per_row: test that copying data with various bytesPerRow (including { ==, > } bytesInACompleteRow) and\\\n rowsPerImage (including { ==, > } copyExtent.height) values and minimum required bytes in copy works for every format. Also covers special code paths:\n  - bufferSize - offset < bytesPerImage * copyExtent.depth\n  - when bytesPerRow is not a multiple of 512 and copyExtent.depth > 1: copyExtent.depth % 2 == { 0, 1 }\n  - bytesPerRow == bytesInACompleteCopyImage\n\n* copy_with_various_offsets_and_data_sizes: test that copying data with various offset (including { ==, > } 0 and is/isn't power of 2) values and additional\\\n data paddings works for every format with 2d and 2d-array textures. Also covers special code paths:\n  - offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n  - offset > bytesInACompleteCopyImage\n\n* copy_with_various_origins_and_copy_extents: test that copying slices of a texture works with various origin (including { origin.x, origin.y, origin.z }\\\n { ==, > } 0 and is/isn't power of 2) and copyExtent (including { copyExtent.x, copyExtent.y, copyExtent.z } { ==, > } 0 and is/isn't power of 2) values\\\n (also including {origin._ + copyExtent._ { ==, < } the subresource size of textureCopyView) works for all formats. origin and copyExtent values are passed\\\n as [number, number, number] instead of GPUExtent3DDict.\n\n* copy_various_mip_levels: test that copying various mip levels works for all formats. Also covers special code paths:\n  - the physical size of the subresouce is not equal to the logical size\n  - bufferSize - offset < bytesPerImage * copyExtent.depth and copyExtent needs to be clamped\n\n* copy_with_no_image_or_slice_padding_and_undefined_values: test that when copying a single row we can set any bytesPerRow value and when copying a single\\\n slice we can set rowsPerImage to 0. Also test setting offset, rowsPerImage, mipLevel, origin, origin.{x,y,z} to undefined.\n\n* TODO:\n  - add another initMethod which renders the texture\n  - test copyT2B with buffer size not divisible by 4 (not done because expectContents 4-byte alignment)\n  - add tests for 1d / 3d textures\n`;\n\nimport { params, poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../common/framework/util/util.js';\nimport {\n  kSizedTextureFormatInfo,\n  SizedTextureFormat,\n  kSizedTextureFormats,\n} from '../../capability_info.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { align } from '../../util/math.js';\nimport { getTextureCopyLayout, TextureCopyLayout } from '../../util/texture/layout.js';\n\ninterface TextureCopyViewWithRequiredOrigin {\n  texture: GPUTexture;\n  mipLevel: number | undefined;\n  origin: Required<GPUOrigin3DDict>;\n}\n\n/** Describes the function used to copy the initial data into the texture. */\ntype InitMethod = 'WriteTexture' | 'CopyB2T';\n/**\n * - PartialCopyT2B: do CopyT2B to check that the part of the texture we copied to with InitMethod\n *   matches the data we were copying and that we don't overwrite any data in the target buffer that\n *   we're not supposed to - that's primarily for testing CopyT2B functionality.\n * - FullCopyT2B: do CopyT2B on the whole texture and check wether the part we copied to matches\n *   the data we were copying and that the nothing else was modified - that's primarily for testing\n *   WriteTexture and CopyB2T.\n */\ntype CheckMethod = 'PartialCopyT2B' | 'FullCopyT2B';\n\n/**\n * This describes in what form the arguments will be passed to WriteTexture/CopyB2T/CopyT2B. If\n * undefined, then default values are passed as undefined instead of default values. If arrays, then\n * `GPUOrigin3D` and `GPUExtent3D` are passed as `[number, number, number]`. *\n */\ntype ChangeBeforePass = 'none' | 'undefined' | 'arrays';\n\n/** Each combination of methods assume that the ones before it were tested and work correctly. */\nconst kMethodsToTest = [\n  // We make sure that CopyT2B works when copying the whole texture for renderable formats:\n  // TODO\n  // Then we make sure that WriteTexture works for all formats:\n  { initMethod: 'WriteTexture', checkMethod: 'FullCopyT2B' },\n  // Then we make sure that CopyB2T works for all formats:\n  { initMethod: 'CopyB2T', checkMethod: 'FullCopyT2B' },\n  // Then we make sure that CopyT2B works for all formats:\n  { initMethod: 'WriteTexture', checkMethod: 'PartialCopyT2B' },\n] as const;\n\nclass CopyBetweenLinearDataAndTextureTest extends GPUTest {\n  bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n    const blockWidth = kSizedTextureFormatInfo[format].blockWidth;\n    assert(copyWidth % blockWidth === 0);\n    const copyWidthInBlocks = copyWidth / blockWidth;\n    return kSizedTextureFormatInfo[format].bytesPerBlock * copyWidthInBlocks;\n  }\n\n  requiredBytesInCopy(\n    layout: Required<GPUTextureDataLayout>,\n    format: SizedTextureFormat,\n    copyExtent: GPUExtent3DDict\n  ): number {\n    assert(layout.rowsPerImage % kSizedTextureFormatInfo[format].blockHeight === 0);\n    assert(copyExtent.height % kSizedTextureFormatInfo[format].blockHeight === 0);\n    assert(copyExtent.width % kSizedTextureFormatInfo[format].blockWidth === 0);\n    if (copyExtent.width === 0 || copyExtent.height === 0 || copyExtent.depth === 0) {\n      return 0;\n    } else {\n      const texelBlockRowsPerImage =\n        layout.rowsPerImage / kSizedTextureFormatInfo[format].blockHeight;\n      const bytesPerImage = layout.bytesPerRow * texelBlockRowsPerImage;\n      const bytesInLastSlice =\n        layout.bytesPerRow * (copyExtent.height / kSizedTextureFormatInfo[format].blockHeight - 1) +\n        (copyExtent.width / kSizedTextureFormatInfo[format].blockWidth) *\n          kSizedTextureFormatInfo[format].bytesPerBlock;\n      return bytesPerImage * (copyExtent.depth - 1) + bytesInLastSlice;\n    }\n  }\n\n  /** Offset for a particular texel in the linear texture data */\n  getTexelOffsetInBytes(\n    textureDataLayout: Required<GPUTextureDataLayout>,\n    format: SizedTextureFormat,\n    texel: Required<GPUOrigin3DDict>,\n    origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 }\n  ): number {\n    const { offset, bytesPerRow, rowsPerImage } = textureDataLayout;\n    const info = kSizedTextureFormatInfo[format];\n\n    assert(texel.x >= origin.x && texel.y >= origin.y && texel.z >= origin.z);\n    assert(rowsPerImage % info.blockHeight === 0);\n    assert(texel.x % info.blockWidth === 0);\n    assert(texel.y % info.blockHeight === 0);\n    assert(origin.x % info.blockWidth === 0);\n    assert(origin.y % info.blockHeight === 0);\n\n    const bytesPerImage = (rowsPerImage / info.blockHeight) * bytesPerRow;\n\n    return (\n      offset +\n      (texel.z - origin.z) * bytesPerImage +\n      ((texel.y - origin.y) / info.blockHeight) * bytesPerRow +\n      ((texel.x - origin.x) / info.blockWidth) * info.bytesPerBlock\n    );\n  }\n\n  *iterateBlockRows(\n    size: GPUExtent3DDict,\n    origin: Required<GPUOrigin3DDict>,\n    format: SizedTextureFormat\n  ): Generator<Required<GPUOrigin3DDict>> {\n    if (size.width === 0 || size.height === 0 || size.depth === 0) {\n      // do not iterate anything for an empty region\n      return;\n    }\n    const info = kSizedTextureFormatInfo[format];\n    assert(size.height % info.blockHeight === 0);\n    for (let y = 0; y < size.height / info.blockHeight; ++y) {\n      for (let z = 0; z < size.depth; ++z) {\n        yield {\n          x: origin.x,\n          y: origin.y + y * info.blockHeight,\n          z: origin.z + z,\n        };\n      }\n    }\n  }\n\n  generateData(byteSize: number, start: number = 0): Uint8Array {\n    const arr = new Uint8Array(byteSize);\n    for (let i = 0; i < byteSize; ++i) {\n      arr[i] = (i ** 3 + i + start) % 251;\n    }\n    return arr;\n  }\n\n  /**\n   * This is used for testing passing undefined members of `GPUTextureDataLayout` instead of actual\n   * values where possible. Passing arguments as values and not as objects so that they are passed\n   * by copy and not by reference.\n   */\n  undefDataLayoutIfNeeded(\n    offset: number | undefined,\n    rowsPerImage: number | undefined,\n    bytesPerRow: number,\n    changeBeforePass: ChangeBeforePass\n  ): GPUTextureDataLayout {\n    if (changeBeforePass === 'undefined') {\n      if (offset === 0) {\n        offset = undefined;\n      }\n      if (rowsPerImage === 0) {\n        rowsPerImage = undefined;\n      }\n    }\n    return { offset, bytesPerRow, rowsPerImage };\n  }\n\n  /**\n   * This is used for testing passing undefined members of `GPUTextureCopyView` instead of actual\n   * values where possible and also for testing passing the origin as `[number, number, number]`.\n   * Passing arguments as values and not as objects so that they are passed by copy and not by\n   * reference.\n   */\n  undefOrArrayCopyViewIfNeeded(\n    texture: GPUTexture,\n    origin_x: number | undefined,\n    origin_y: number | undefined,\n    origin_z: number | undefined,\n    mipLevel: number | undefined,\n    changeBeforePass: ChangeBeforePass\n  ): GPUTextureCopyView {\n    let origin: GPUOrigin3D | undefined = { x: origin_x, y: origin_y, z: origin_z };\n\n    if (changeBeforePass === 'undefined') {\n      if (origin_x === 0 && origin_y === 0 && origin_z === 0) {\n        origin = undefined;\n      } else {\n        if (origin_x === 0) {\n          origin_x = undefined;\n        }\n        if (origin_y === 0) {\n          origin_y = undefined;\n        }\n        if (origin_z === 0) {\n          origin_z = undefined;\n        }\n        origin = { x: origin_x, y: origin_y, z: origin_z };\n      }\n\n      if (mipLevel === 0) {\n        mipLevel = undefined;\n      }\n    }\n\n    if (changeBeforePass === 'arrays') {\n      origin = [origin_x!, origin_y!, origin_z!];\n    }\n\n    return { texture, origin, mipLevel };\n  }\n\n  /**\n   * This is used for testing passing `GPUExtent3D` as `[number, number, number]` instead of\n   * `GPUExtent3DDict`. Passing arguments as values and not as objects so that they are passed by\n   * copy and not by reference.\n   */\n  arrayCopySizeIfNeeded(\n    width: number,\n    height: number,\n    depth: number,\n    changeBeforePass: ChangeBeforePass\n  ): GPUExtent3D {\n    if (changeBeforePass === 'arrays') {\n      return [width, height, depth];\n    } else {\n      return { width, height, depth };\n    }\n  }\n\n  /** Run a CopyT2B command with appropriate arguments corresponding to `ChangeBeforePass` */\n  copyTextureToBufferWithAppliedArguments(\n    buffer: GPUBuffer,\n    { offset, rowsPerImage, bytesPerRow }: Required<GPUTextureDataLayout>,\n    { width, height, depth }: GPUExtent3DDict,\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    changeBeforePass: ChangeBeforePass\n  ): void {\n    const { x, y, z } = origin;\n\n    const appliedCopyView = this.undefOrArrayCopyViewIfNeeded(\n      texture,\n      x,\n      y,\n      z,\n      mipLevel,\n      changeBeforePass\n    );\n    const appliedDataLayout = this.undefDataLayoutIfNeeded(\n      offset,\n      rowsPerImage,\n      bytesPerRow,\n      changeBeforePass\n    );\n    const appliedCheckSize = this.arrayCopySizeIfNeeded(width, height, depth, changeBeforePass);\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      appliedCopyView,\n      { buffer, ...appliedDataLayout },\n      appliedCheckSize\n    );\n    this.device.defaultQueue.submit([encoder.finish()]);\n  }\n\n  /** Put data into a part of the texture with an appropriate method. */\n  uploadLinearTextureDataToTextureSubBox(\n    textureCopyView: TextureCopyViewWithRequiredOrigin,\n    textureDataLayout: GPUTextureDataLayout,\n    copySize: GPUExtent3DDict,\n    partialData: Uint8Array,\n    method: InitMethod,\n    changeBeforePass: ChangeBeforePass\n  ): void {\n    const { texture, mipLevel, origin } = textureCopyView;\n    const { offset, rowsPerImage, bytesPerRow } = textureDataLayout;\n    const { x, y, z } = origin;\n    const { width, height, depth } = copySize;\n\n    const appliedCopyView = this.undefOrArrayCopyViewIfNeeded(\n      texture,\n      x,\n      y,\n      z,\n      mipLevel,\n      changeBeforePass\n    );\n    const appliedDataLayout = this.undefDataLayoutIfNeeded(\n      offset,\n      rowsPerImage,\n      bytesPerRow,\n      changeBeforePass\n    );\n    const appliedCopySize = this.arrayCopySizeIfNeeded(width, height, depth, changeBeforePass);\n\n    switch (method) {\n      case 'WriteTexture': {\n        this.device.defaultQueue.writeTexture(\n          appliedCopyView,\n          partialData,\n          appliedDataLayout,\n          appliedCopySize\n        );\n\n        break;\n      }\n      case 'CopyB2T': {\n        const buffer = this.device.createBuffer({\n          mappedAtCreation: true,\n          size: align(partialData.byteLength, 4),\n          usage: GPUBufferUsage.COPY_SRC,\n        });\n        new Uint8Array(buffer.getMappedRange()).set(partialData);\n        buffer.unmap();\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyBufferToTexture(\n          { buffer, ...appliedDataLayout },\n          appliedCopyView,\n          appliedCopySize\n        );\n        this.device.defaultQueue.submit([encoder.finish()]);\n\n        break;\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  /**\n   * We check an appropriate part of the texture against the given data.\n   * Used directly with PartialCopyT2B check method (for a subpart of the texture)\n   * and by `copyWholeTextureToBufferAndCheckContentsWithUpdatedData` with FullCopyT2B check method\n   * (for the whole texture). We also ensure that CopyT2B doesn't overwrite bytes it's not supposed\n   * to if validateOtherBytesInBuffer is set to true.\n   */\n  copyPartialTextureToBufferAndCheckContents(\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    checkSize: GPUExtent3DDict,\n    format: SizedTextureFormat,\n    expected: Uint8Array,\n    expectedDataLayout: Required<GPUTextureDataLayout>,\n    changeBeforePass: ChangeBeforePass = 'none'\n  ): void {\n    // The alignment is necessary because we need to copy and map data from this buffer.\n    const bufferSize = align(expected.byteLength, 4);\n    // The start value ensures generated data here doesn't match the expected data.\n    const bufferData = this.generateData(bufferSize, 17);\n\n    const buffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    new Uint8Array(buffer.getMappedRange()).set(bufferData);\n    buffer.unmap();\n\n    this.copyTextureToBufferWithAppliedArguments(\n      buffer,\n      expectedDataLayout,\n      checkSize,\n      { texture, mipLevel, origin },\n      changeBeforePass\n    );\n\n    this.updateLinearTextureDataSubBox(\n      expectedDataLayout,\n      expectedDataLayout,\n      checkSize,\n      origin,\n      format,\n      bufferData,\n      expected\n    );\n\n    this.expectContents(buffer, bufferData);\n  }\n\n  /**\n   * Copies the whole texture into linear data stored in a buffer for further checks.\n   *\n   * Used for `copyWholeTextureToBufferAndCheckContentsWithUpdatedData`.\n   */\n  copyWholeTextureToNewBuffer(\n    { texture, mipLevel }: { texture: GPUTexture; mipLevel: number | undefined },\n    resultDataLayout: TextureCopyLayout\n  ): GPUBuffer {\n    const { mipSize, byteLength, bytesPerRow, rowsPerImage } = resultDataLayout;\n    const buffer = this.device.createBuffer({\n      size: align(byteLength, 4), // this is necessary because we need to copy and map data from this buffer\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      { texture, mipLevel },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.device.defaultQueue.submit([encoder.finish()]);\n\n    return buffer;\n  }\n\n  copyFromArrayToArray(\n    src: Uint8Array,\n    srcOffset: number,\n    dst: Uint8Array,\n    dstOffset: number,\n    size: number\n  ): void {\n    dst.set(src.subarray(srcOffset, srcOffset + size), dstOffset);\n  }\n\n  /**\n   * Takes the data returned by `copyWholeTextureToNewBuffer` and updates it after a copy operation\n   * on the texture by emulating the copy behaviour here directly.\n   */\n  updateLinearTextureDataSubBox(\n    { bytesPerRow, rowsPerImage }: { bytesPerRow: number; rowsPerImage: number },\n    sourceDataLayout: Required<GPUTextureDataLayout>,\n    copySize: GPUExtent3DDict,\n    origin: Required<GPUOrigin3DDict>,\n    format: SizedTextureFormat,\n    destination: Uint8Array,\n    source: Uint8Array\n  ): void {\n    for (const texel of this.iterateBlockRows(copySize, origin, format)) {\n      const sourceOffset = this.getTexelOffsetInBytes(sourceDataLayout, format, texel, origin);\n      const destinationOffset = this.getTexelOffsetInBytes(\n        { bytesPerRow, rowsPerImage, offset: 0 },\n        format,\n        texel\n      );\n      const rowLength = this.bytesInACompleteRow(copySize.width, format);\n      this.copyFromArrayToArray(source, sourceOffset, destination, destinationOffset, rowLength);\n    }\n  }\n\n  /**\n   * Used for checking whether the whole texture was updated correctly by\n   * `uploadLinearTextureDataToTextureSubpart`. Takes fullData returned by\n   * `copyWholeTextureToNewBuffer` before the copy operation which is the original texture data,\n   * then updates it with `updateLinearTextureDataSubpart` and checks the texture against the\n   * updated data after the copy operation.\n   */\n  copyWholeTextureToBufferAndCheckContentsWithUpdatedData(\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    fullTextureCopyLayout: TextureCopyLayout,\n    texturePartialDataLayout: Required<GPUTextureDataLayout>,\n    copySize: GPUExtent3DDict,\n    format: SizedTextureFormat,\n    fullData: GPUBuffer,\n    partialData: Uint8Array\n  ): void {\n    const { mipSize, bytesPerRow, rowsPerImage, byteLength } = fullTextureCopyLayout;\n    const { dst, begin, end } = this.createAlignedCopyForMapRead(fullData, byteLength, 0);\n\n    // We add an eventual async expectation which will update the full data and then add\n    // other eventual async expectations to ensure it will be correct.\n    this.eventualAsyncExpectation(async () => {\n      await dst.mapAsync(GPUMapMode.READ);\n      const actual = new Uint8Array(dst.getMappedRange()).subarray(begin, end);\n      this.updateLinearTextureDataSubBox(\n        fullTextureCopyLayout,\n        texturePartialDataLayout,\n        copySize,\n        origin,\n        format,\n        actual,\n        partialData\n      );\n      this.copyPartialTextureToBufferAndCheckContents(\n        { texture, mipLevel, origin: { x: 0, y: 0, z: 0 } },\n        { width: mipSize[0], height: mipSize[1], depth: mipSize[2] },\n        format,\n        actual,\n        { bytesPerRow, rowsPerImage, offset: 0 }\n      );\n      dst.destroy();\n    });\n  }\n\n  /**\n   * Tests copy between linear data and texture by creating a texture, putting some data into it\n   * with WriteTexture/CopyB2T, then getting data for the whole texture/for a part of it back and\n   * comparing it with the expectation.\n   */\n  uploadTextureAndVerifyCopy({\n    textureDataLayout,\n    copySize,\n    dataSize,\n    mipLevel = 0,\n    origin = { x: 0, y: 0, z: 0 },\n    textureSize,\n    format,\n    dimension = '2d',\n    initMethod,\n    checkMethod,\n    changeBeforePass = 'none',\n  }: {\n    textureDataLayout: Required<GPUTextureDataLayout>;\n    copySize: GPUExtent3DDict;\n    dataSize: number;\n    mipLevel?: number;\n    origin?: Required<GPUOrigin3DDict>;\n    textureSize: [number, number, number];\n    format: SizedTextureFormat;\n    dimension?: GPUTextureDimension;\n    initMethod: InitMethod;\n    checkMethod: CheckMethod;\n    changeBeforePass?: ChangeBeforePass;\n  }): void {\n    const texture = this.device.createTexture({\n      size: textureSize,\n      format,\n      dimension,\n      mipLevelCount: mipLevel + 1,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const data = this.generateData(dataSize);\n\n    switch (checkMethod) {\n      case 'PartialCopyT2B': {\n        this.uploadLinearTextureDataToTextureSubBox(\n          { texture, mipLevel, origin },\n          textureDataLayout,\n          copySize,\n          data,\n          initMethod,\n          changeBeforePass\n        );\n\n        this.copyPartialTextureToBufferAndCheckContents(\n          { texture, mipLevel, origin },\n          copySize,\n          format,\n          data,\n          textureDataLayout,\n          changeBeforePass\n        );\n\n        break;\n      }\n      case 'FullCopyT2B': {\n        const fullTextureCopyLayout = getTextureCopyLayout(format, dimension, textureSize, {\n          mipLevel,\n        });\n\n        const fullData = this.copyWholeTextureToNewBuffer(\n          { texture, mipLevel },\n          fullTextureCopyLayout\n        );\n\n        this.uploadLinearTextureDataToTextureSubBox(\n          { texture, mipLevel, origin },\n          textureDataLayout,\n          copySize,\n          data,\n          initMethod,\n          changeBeforePass\n        );\n\n        this.copyWholeTextureToBufferAndCheckContentsWithUpdatedData(\n          { texture, mipLevel, origin },\n          fullTextureCopyLayout,\n          textureDataLayout,\n          copySize,\n          format,\n          fullData,\n          data\n        );\n\n        break;\n      }\n      default:\n        unreachable();\n    }\n  }\n}\n\n/**\n * This is a helper function used for filtering test parameters\n *\n * TODO: Modify this after introducing tests with rendering.\n */\nfunction formatCanBeTested({ format }: { format: SizedTextureFormat }): boolean {\n  return kSizedTextureFormatInfo[format].copyDst && kSizedTextureFormatInfo[format].copySrc;\n}\n\nexport const g = makeTestGroup(CopyBetweenLinearDataAndTextureTest);\n\n// Test that copying data with various bytesPerRow and rowsPerImage values and minimum required\n// bytes in copy works for every format.\n// Covers a special code path for Metal:\n//    bufferSize - offset < bytesPerImage * copyExtent.depth\n// Covers a special code path for D3D12:\n//    when bytesPerRow is not a multiple of 512 and copyExtent.depth > 1: copyExtent.depth % 2 == { 0, 1 }\n//    bytesPerRow == bytesInACompleteCopyImage */\ng.test('copy_with_various_rows_per_image_and_bytes_per_row')\n  .params(\n    params()\n      .combine(kMethodsToTest)\n      .combine([\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 0 }, // no padding\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 6 }, // rowsPerImage padding\n        { bytesPerRowPadding: 6, rowsPerImagePaddingInBlocks: 0 }, // bytesPerRow padding\n        { bytesPerRowPadding: 15, rowsPerImagePaddingInBlocks: 17 }, // both paddings\n      ])\n      .combine([\n        // In the two cases below, for (WriteTexture, PartialCopyB2T) and (CopyB2T, FullCopyT2B)\n        // sets of methods we will have bytesPerRow = 256 and copyDepth % 2 == { 0, 1 }\n        // respectively. This covers a special code path for D3D12.\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5 }, // standard copy\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 2 }, // standard copy\n\n        { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2 }, // copyWidth is 256-aligned\n        { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5 }, // empty copy because of width\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5 }, // empty copy because of height\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0 }, // empty copy because of depth\n        { copyWidthInBlocks: 1, copyHeightInBlocks: 3, copyDepth: 5 }, // copyWidth = 1\n\n        // The two cases below cover another special code path for D3D12.\n        //   - For (WriteTexture, FullCopyT2B) with r8unorm:\n        //         bytesPerRow = 15 = 3 * 5 = bytesInACompleteCopyImage.\n        { copyWidthInBlocks: 32, copyHeightInBlocks: 1, copyDepth: 8 }, // copyHeight = 1\n        //   - For (CopyB2T, FullCopyT2B) and (WriteTexture, PartialCopyT2B) with r8unorm:\n        //         bytesPerRow = 256 = 8 * 32 = bytesInACompleteCopyImage.\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1 }, // copyDepth = 1\n\n        { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1 }, // copyHeight = 1 and copyDepth = 1\n      ])\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCanBeTested)\n  )\n  .fn(async t => {\n    const {\n      bytesPerRowPadding,\n      rowsPerImagePaddingInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n\n    const info = kSizedTextureFormatInfo[format];\n\n    // For CopyB2T and CopyT2B we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment =\n      initMethod === 'WriteTexture' && checkMethod === 'FullCopyT2B' ? 1 : 256;\n\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const rowsPerImage = copyHeight + rowsPerImagePaddingInBlocks * info.blockHeight;\n    const bytesPerRow =\n      align(t.bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const copySize = { width: copyWidth, height: copyHeight, depth: copyDepth };\n\n    const minDataSize = t.requiredBytesInCopy(\n      { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize\n    );\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize: minDataSize,\n      textureSize: [\n        Math.max(copyWidth, info.blockWidth),\n        Math.max(copyHeight, info.blockHeight),\n        Math.max(copyDepth, 1),\n      ] /* making sure the texture is non-empty */,\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\n// Test that copying data with various offset values and additional data paddings\n// works for every format with 2d and 2d-array textures.\n// Covers two special code paths for D3D12:\n//     offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n//     offset > bytesInACompleteCopyImage\ng.test('copy_with_various_offsets_and_data_sizes')\n  .params(\n    params()\n      .combine(kMethodsToTest)\n      .combine([\n        { offsetInBlocks: 0, dataPaddingInBytes: 0 }, // no offset and no padding\n        { offsetInBlocks: 1, dataPaddingInBytes: 0 }, // offset = 1\n        { offsetInBlocks: 2, dataPaddingInBytes: 0 }, // offset = 2\n        { offsetInBlocks: 15, dataPaddingInBytes: 0 }, // offset = 15\n        { offsetInBlocks: 16, dataPaddingInBytes: 0 }, // offset = 16\n        { offsetInBlocks: 242, dataPaddingInBytes: 0 }, // for rgba8unorm format: offset + bytesInCopyExtentPerRow = 242 + 12 = 256 = bytesPerRow\n        { offsetInBlocks: 243, dataPaddingInBytes: 0 }, // for rgba8unorm format: offset + bytesInCopyExtentPerRow = 243 + 12 > 256 = bytesPerRow\n        { offsetInBlocks: 768, dataPaddingInBytes: 0 }, // for copyDepth = 1, blockWidth = 1 and bytesPerBlock = 1: offset = 768 = 3 * 256 = bytesInACompleteCopyImage\n        { offsetInBlocks: 769, dataPaddingInBytes: 0 }, // for copyDepth = 1, blockWidth = 1 and bytesPerBlock = 1: offset = 769 > 768 = bytesInACompleteCopyImage\n        { offsetInBlocks: 0, dataPaddingInBytes: 1 }, // dataPaddingInBytes > 0\n        { offsetInBlocks: 1, dataPaddingInBytes: 8 }, // offset > 0 and dataPaddingInBytes > 0\n      ])\n      .combine(poptions('copyDepth', [1, 2])) // 2d and 2d-array textures\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCanBeTested)\n  )\n  .fn(async t => {\n    const {\n      offsetInBlocks,\n      dataPaddingInBytes,\n      copyDepth,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n\n    const info = kSizedTextureFormatInfo[format];\n\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const copySize = {\n      width: 3 * info.blockWidth,\n      height: 3 * info.blockHeight,\n      depth: copyDepth,\n    };\n    const rowsPerImage = copySize.height;\n    const bytesPerRow = 256;\n\n    const dataSize =\n      offset +\n      t.requiredBytesInCopy({ offset, bytesPerRow, rowsPerImage }, format, copySize) +\n      dataPaddingInBytes;\n\n    // We're copying a (3 x 3 x copyDepth) (in texel blocks) part of a (4 x 4 x copyDepth)\n    // (in texel blocks) texture with no origin.\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      textureSize: [4 * info.blockWidth, 4 * info.blockHeight, copyDepth],\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\n// Test that copying slices of a texture works with various origin and copyExtent values\n// for all formats. We pass origin and copyExtent as [number, number, number].\ng.test('copy_with_various_origins_and_copy_extents')\n  .params(\n    params()\n      .combine(kMethodsToTest)\n      .combine(poptions('originValueInBlocks', [0, 7, 8]))\n      .combine(poptions('copySizeValueInBlocks', [0, 7, 8]))\n      .combine(poptions('textureSizePaddingValueInBlocks', [0, 7, 8]))\n      .unless(\n        p =>\n          // we can't create an empty texture\n          p.copySizeValueInBlocks + p.originValueInBlocks + p.textureSizePaddingValueInBlocks === 0\n      )\n      .combine(poptions('coordinateToTest', ['width', 'height', 'depth'] as const))\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCanBeTested)\n  )\n  .fn(async t => {\n    const {\n      coordinateToTest,\n      originValueInBlocks,\n      copySizeValueInBlocks,\n      textureSizePaddingValueInBlocks,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n\n    const info = kSizedTextureFormatInfo[format];\n\n    const origin: Required<GPUOrigin3DDict> = { x: info.blockWidth, y: info.blockHeight, z: 1 };\n    const copySize = { width: 2 * info.blockWidth, height: 2 * info.blockHeight, depth: 2 };\n    const textureSize: [number, number, number] = [3 * info.blockWidth, 3 * info.blockHeight, 3];\n\n    switch (coordinateToTest) {\n      case 'width': {\n        origin.x = originValueInBlocks * info.blockWidth;\n        copySize.width = copySizeValueInBlocks * info.blockWidth;\n        textureSize[0] =\n          origin.x + copySize.width + textureSizePaddingValueInBlocks * info.blockWidth;\n        break;\n      }\n      case 'height': {\n        origin.y = originValueInBlocks * info.blockHeight;\n        copySize.height = copySizeValueInBlocks * info.blockHeight;\n        textureSize[1] =\n          origin.y + copySize.height + textureSizePaddingValueInBlocks * info.blockHeight;\n        break;\n      }\n      case 'depth': {\n        origin.z = originValueInBlocks;\n        copySize.depth = copySizeValueInBlocks;\n        textureSize[2] = origin.z + copySize.depth + textureSizePaddingValueInBlocks;\n        break;\n      }\n    }\n\n    const rowsPerImage = copySize.height;\n    const bytesPerRow = align(copySize.width, 256);\n    const dataSize = t.requiredBytesInCopy(\n      { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize\n    );\n\n    // For testing width: we copy a (_ x 2 x 2) (in texel blocks) part of a (_ x 3 x 3)\n    // (in texel blocks) texture with origin (_, 1, 1) (in texel blocks).\n    // Similarly for other coordinates.\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      origin,\n      textureSize,\n      format,\n      initMethod,\n      checkMethod,\n      changeBeforePass: 'arrays',\n    });\n  });\n\n/**\n * Generates textureSizes which correspond to the same physicalSizeAtMipLevel including virtual\n * sizes at mip level different from the physical ones.\n */\nfunction* textureSizeExpander({\n  format,\n  mipLevel,\n  _texturePhysicalSizeAtMipLevelInBlocks,\n}: {\n  format: SizedTextureFormat;\n  mipLevel: number;\n  _texturePhysicalSizeAtMipLevelInBlocks: GPUExtent3DDict;\n}): Generator<{ textureSize: [number, number, number] }> {\n  const info = kSizedTextureFormatInfo[format];\n\n  const widthAtThisLevel = _texturePhysicalSizeAtMipLevelInBlocks.width * info.blockWidth;\n  const heightAtThisLevel = _texturePhysicalSizeAtMipLevelInBlocks.height * info.blockHeight;\n  const textureSize: [number, number, number] = [\n    widthAtThisLevel << mipLevel,\n    heightAtThisLevel << mipLevel,\n    _texturePhysicalSizeAtMipLevelInBlocks.depth,\n  ];\n  yield {\n    textureSize,\n  };\n\n  // We choose width and height of the texture so that the values are divisible by blockWidth and\n  // blockHeight respectively and so that the virtual size at mip level corresponds to the same\n  // physical size.\n  // Virtual size at mip level with modified width has width = (physical size width) - (blockWidth / 2).\n  // Virtual size at mip level with modified height has height = (physical size height) - (blockHeight / 2).\n  const widthAtPrevLevel = widthAtThisLevel << 1;\n  const heightAtPrevLevel = heightAtThisLevel << 1;\n  assert(mipLevel > 0);\n  assert(widthAtPrevLevel >= info.blockWidth && heightAtPrevLevel >= info.blockHeight);\n  const modifiedWidth = (widthAtPrevLevel - info.blockWidth) << (mipLevel - 1);\n  const modifiedHeight = (heightAtPrevLevel - info.blockHeight) << (mipLevel - 1);\n\n  const modifyWidth = info.blockWidth > 1 && modifiedWidth !== textureSize[0];\n  const modifyHeight = info.blockHeight > 1 && modifiedHeight !== textureSize[1];\n\n  if (modifyWidth) {\n    yield {\n      textureSize: [modifiedWidth, textureSize[1], textureSize[2]],\n    };\n  }\n  if (modifyHeight) {\n    yield {\n      textureSize: [textureSize[0], modifiedHeight, textureSize[2]],\n    };\n  }\n  if (modifyWidth && modifyHeight) {\n    yield {\n      textureSize: [modifiedWidth, modifiedHeight, textureSize[2]],\n    };\n  }\n}\n\n// Test that copying various mip levels works.\n// Covers two special code paths:\n//   - the physical size of the subresouce is not equal to the logical size\n//   - bufferSize - offset < bytesPerImage * copyExtent.depth and copyExtent needs to be clamped for all block formats */\ng.test('copy_various_mip_levels')\n  .params(\n    params()\n      .combine(kMethodsToTest)\n      .combine([\n        // origin + copySize = texturePhysicalSizeAtMipLevel for all coordinates, 2d texture */\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 1 },\n          originInBlocks: { x: 3, y: 2, z: 0 },\n          _texturePhysicalSizeAtMipLevelInBlocks: { width: 8, height: 6, depth: 1 },\n          mipLevel: 1,\n        },\n        // origin + copySize = texturePhysicalSizeAtMipLevel for all coordinates, 2d-array texture\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _texturePhysicalSizeAtMipLevelInBlocks: { width: 8, height: 6, depth: 3 },\n          mipLevel: 2,\n        },\n        // origin.x + copySize.width = texturePhysicalSizeAtMipLevel.width\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _texturePhysicalSizeAtMipLevelInBlocks: { width: 8, height: 7, depth: 4 },\n          mipLevel: 3,\n        },\n        // origin.y + copySize.height = texturePhysicalSizeAtMipLevel.height\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _texturePhysicalSizeAtMipLevelInBlocks: { width: 9, height: 6, depth: 4 },\n          mipLevel: 4,\n        },\n        // origin.z + copySize.depth = texturePhysicalSizeAtMipLevel.depth\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _texturePhysicalSizeAtMipLevelInBlocks: { width: 9, height: 7, depth: 3 },\n          mipLevel: 5,\n        },\n        // origin + copySize < texturePhysicalSizeAtMipLevel for all coordinates\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _texturePhysicalSizeAtMipLevelInBlocks: { width: 9, height: 7, depth: 4 },\n          mipLevel: 6,\n        },\n      ])\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCanBeTested)\n      .expand(textureSizeExpander)\n  )\n  .fn(async t => {\n    const {\n      copySizeInBlocks,\n      originInBlocks,\n      textureSize,\n      mipLevel,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n\n    const info = kSizedTextureFormatInfo[format];\n\n    const origin = {\n      x: originInBlocks.x * info.blockWidth,\n      y: originInBlocks.y * info.blockHeight,\n      z: originInBlocks.z,\n    };\n    const copySize = {\n      width: copySizeInBlocks.width * info.blockWidth,\n      height: copySizeInBlocks.height * info.blockHeight,\n      depth: copySizeInBlocks.depth,\n    };\n\n    const rowsPerImage = copySize.height + info.blockHeight;\n    const bytesPerRow = align(copySize.width, 256);\n    const dataSize = t.requiredBytesInCopy(\n      { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize\n    );\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      origin,\n      mipLevel,\n      textureSize,\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\n// Test that when copying a single row we can set any bytesPerRow value and when copying a single\n// slice we can set rowsPerImage to 0. Origin, offset, mipLevel and rowsPerImage values will be set\n// to undefined when appropriate.\ng.test('copy_with_no_image_or_slice_padding_and_undefined_values')\n  .params(\n    params()\n      .combine(kMethodsToTest)\n      .combine([\n        // copying one row: bytesPerRow and rowsPerImage can be set to 0\n        {\n          bytesPerRow: 0,\n          rowsPerImage: 0,\n          copySize: { width: 3, height: 1, depth: 1 },\n          origin: { x: 0, y: 0, z: 0 },\n        },\n        // copying one row: bytesPerRow can be < bytesInACompleteRow = 400\n        {\n          bytesPerRow: 256,\n          rowsPerImage: 0,\n          copySize: { width: 100, height: 1, depth: 1 },\n          origin: { x: 0, y: 0, z: 0 },\n        },\n        // copying one slice: rowsPerImage = 0 will be set to undefined\n        {\n          bytesPerRow: 256,\n          rowsPerImage: 0,\n          copySize: { width: 3, height: 3, depth: 1 },\n          origin: { x: 0, y: 0, z: 0 },\n        },\n        // copying one slice: rowsPerImage = 2 is valid\n        {\n          bytesPerRow: 256,\n          rowsPerImage: 2,\n          copySize: { width: 3, height: 3, depth: 1 },\n          origin: { x: 0, y: 0, z: 0 },\n        },\n        // origin.x = 0 will be set to undefined\n        {\n          bytesPerRow: 0,\n          rowsPerImage: 0,\n          copySize: { width: 1, height: 1, depth: 1 },\n          origin: { x: 0, y: 1, z: 1 },\n        },\n        // origin.y = 0 will be set to undefined\n        {\n          bytesPerRow: 0,\n          rowsPerImage: 0,\n          copySize: { width: 1, height: 1, depth: 1 },\n          origin: { x: 1, y: 0, z: 1 },\n        },\n        // origin.z = 0 will be set to undefined\n        {\n          bytesPerRow: 0,\n          rowsPerImage: 0,\n          copySize: { width: 1, height: 1, depth: 1 },\n          origin: { x: 1, y: 1, z: 0 },\n        },\n      ])\n  )\n  .fn(async t => {\n    const { bytesPerRow, rowsPerImage, copySize, origin, initMethod, checkMethod } = t.params;\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize: 100 * 3 * 4,\n      textureSize: [100, 3, 2],\n      origin,\n      format: 'rgba8unorm',\n      initMethod,\n      checkMethod,\n      changeBeforePass: 'undefined',\n    });\n  });\n"],"file":"copyBetweenLinearDataAndTexture.spec.js"}
{"version":3,"sources":["../../../../../../src/webgpu/api/operation/memory_sync/buffer/rw_and_wr.spec.ts"],"names":["description","makeTestGroup","BufferSyncTest","g"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAfO,CAiBP,SAASC,aAAT,QAA8B,+CAA9B;;AAEA,SAASC,cAAT,QAA+B,uBAA/B;;AAEA,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,cAAD,CAAvB","sourcesContent":["export const description = `\nMemory Synchronization Tests for Buffer: read before write and read after write.\n\n- Create a single buffer and initialize it to 0, wait on the fence to ensure the data is initialized.\nWrite a number (say 1) into the buffer via render pass, compute pass, copy or writeBuffer.\nRead the data and use it in render, compute, or copy.\nWait on another fence, then call expectContents to verify the written buffer.\nThis is a read-after write test but if the write and read operations are reversed, it will be a read-before-write test.\n  - x= write op: {storage buffer in {compute, render, render-via-bundle}, t2b copy dst, b2b copy dst, writeBuffer}\n  - x= read op: {index buffer, vertex buffer, indirect buffer, uniform buffer, {readonly, readwrite} storage buffer in {compute, render, render-via-bundle}, b2b copy src, b2t copy src}\n  - x= read-write sequence: {read then write, write then read}\n  - if pass type is the same, x= {single pass, separate passes} (note: render has loose guarantees)\n  - if not single pass, x= writes in {same cmdbuf, separate cmdbufs, separate submits, separate queues}\n\nTODO: Tests with more than one buffer to try to stress implementations a little bit more.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\n\nimport { BufferSyncTest } from './buffer_sync_test.js';\n\nexport const g = makeTestGroup(BufferSyncTest);\n"],"file":"rw_and_wr.spec.js"}
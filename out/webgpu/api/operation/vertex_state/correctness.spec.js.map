{"version":3,"sources":["../../../../../src/webgpu/api/operation/vertex_state/correctness.spec.ts"],"names":["description","makeTestGroup","GPUTest","g"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAzCO,CA2CP,SAASC,aAAT,QAA8B,4CAA9B;AACA,SAASC,OAAT,QAAwB,sBAAxB;;AAEA,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,OAAD,CAAvB","sourcesContent":["export const description = `\n- Tests that render N points, using a generated pipeline with:\n  (1) a vertex shader that has necessary vertex inputs and a static array of\n  expected data (as indexed by vertexID + instanceID * verticesPerInstance),\n  which checks they're equal and sends the bool to the fragment shader;\n  (2) a fragment shader which writes the result out to a storage buffer\n  (or renders a red/green fragment if we can't do fragmentStoresAndAtomics,\n  maybe with some depth or stencil test magic to do the '&&' of all fragments).\n    - Fill some GPUBuffers with testable data, e.g.\n      [[1.0, 2.0, ...], [-1.0, -2.0, ...]], for use as vertex buffers.\n    - With no/trivial indexing\n        - Either non-indexed, or indexed with a passthrough index buffer ([0, 1, 2, ...])\n            - Of either format\n            - If non-indexed, index format has no effect\n        - Vertex data is read from the buffer correctly\n            - setVertexBuffer offset\n            - Several vertex buffers with several attributes each\n                - Two setVertexBuffers pointing at the same GPUBuffer (if possible)\n                    - Overlapping, non-overlapping\n                - Overlapping attributes (iff that's supposed to work)\n                - Overlapping vertex buffer elements\n                  (an attribute offset + its size > arrayStride)\n                  (iff that's supposed to work)\n                - Zero, one, or two vertex buffers have stepMode \"instance\"\n                - Discontiguous vertex buffer slots, e.g.\n                  [1, some large number (API doesn't practically allow huge numbers here)]\n                - Discontiguous shader locations, e.g.\n                  [2, some large number (max if possible)]\n             - Bind everything possible up to limits\n                 - Also with maxed out attributes?\n             - x= all vertex formats\n        - Data is fed into the shader correctly\n            - Swap attribute order (should have no effect)\n            - Vertex formats x shader input types (should all be valid, I think?)\n        - Maybe a test of one buffer with two attributes, with every possible\n          pair of vertex formats\n    - With indexing. For each index format:\n        - Indices are read from the buffer correctly\n            - setIndexBuffer offset\n        - For each vertex format:\n            - Basic test with several vertex buffers and several attributes\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n"],"file":"correctness.spec.js"}
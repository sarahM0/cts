{"version":3,"sources":["../../../../../src/webgpu/api/operation/render_pass/resolve.spec.ts"],"names":["description","params","poptions","makeTestGroup","GPUTest","kSlotsToResolve","kSize","kFormat","g","test","combine","fn","t","colorStateDescriptors","i","numColorAttachments","push","format","pipeline","device","createRenderPipeline","vertexStage","module","createShaderModule","code","entryPoint","fragmentStage","primitiveTopology","colorStates","sampleCount","resolveTargets","renderPassColorAttachmentDescriptors","kResolveTargetSize","resolveTargetBaseMipLevel","colorAttachment","createTexture","size","width","height","depth","mipLevelCount","usage","GPUTextureUsage","COPY_DST","COPY_SRC","OUTPUT_ATTACHMENT","slotsToResolve","includes","resolveTarget","resolveTargetBaseArrayLayer","attachment","createView","loadValue","r","b","a","storeOp","storeOperation","baseMipLevel","baseArrayLayer","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","setPipeline","draw","endPass","defaultQueue","submit","finish","length","expectSinglePixelIn2DTexture","x","y","exp","Uint8Array","slice","layout","mipLevel"],"mappings":"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","sourcesContent":["export const description = `API Operation Tests for RenderPass StoreOp.\nTests a render pass with a resolveTarget resolves correctly for many combinations of:\n  - number of color attachments, some with and some without a resolveTarget\n  - renderPass storeOp set to {'store', 'clear'}\n  - resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (TODO?: different z from colorAttachment)\n  - TODO: test all renderable color formats\n  - TODO: test that any not-resolved attachments are rendered to correctly.\n  - TODO: test different loadOps\n  - TODO?: resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - TODO?: resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (different z from colorAttachment)\n`;\n\nimport { params, poptions } from '../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nconst kSlotsToResolve = [\n  [0, 2],\n  [1, 3],\n  [0, 1, 2, 3],\n];\n\nconst kSize = 4;\nconst kFormat: GPUTextureFormat = 'rgba8unorm';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('render_pass_resolve')\n  .params(\n    params()\n      .combine(poptions('numColorAttachments', [2, 4] as const))\n      .combine(poptions('slotsToResolve', kSlotsToResolve))\n      .combine(poptions('storeOperation', ['clear', 'store'] as const))\n      .combine(poptions('resolveTargetBaseMipLevel', [0, 1] as const))\n      .combine(poptions('resolveTargetBaseArrayLayer', [0, 1] as const))\n  )\n  .fn(t => {\n    const colorStateDescriptors: GPUColorStateDescriptor[] = [];\n    for (let i = 0; i < t.params.numColorAttachments; i++) {\n      colorStateDescriptors.push({ format: kFormat });\n    }\n\n    // These shaders will draw a white triangle into a texture. After draw, the top left\n    // half of the texture will be white, and the bottom right half will be unchanged. When this\n    // texture is resolved, there will be two distinct colors in each portion of the texture, as\n    // well as a line between the portions that contain the midpoint color due to the multisample\n    // resolve.\n    const pipeline = t.device.createRenderPipeline({\n      vertexStage: {\n        module: t.device.createShaderModule({\n          code: `\n            [[builtin(position)]] var<out> Position : vec4<f32>;\n            [[builtin(vertex_index)]] var<in> VertexIndex : i32;\n\n            [[stage(vertex)]] fn main() -> void {\n              const pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                  vec2<f32>(-1.0, -1.0),\n                  vec2<f32>(-1.0,  1.0),\n                  vec2<f32>( 1.0,  1.0));\n              Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n              return;\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: t.device.createShaderModule({\n          code: `\n            [[location(0)]] var<out> fragColor0 : vec4<f32>;\n            [[location(1)]] var<out> fragColor1 : vec4<f32>;\n            [[location(2)]] var<out> fragColor2 : vec4<f32>;\n            [[location(3)]] var<out> fragColor3 : vec4<f32>;\n\n            [[stage(fragment)]] fn main() -> void {\n              fragColor0 = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n              fragColor1 = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n              fragColor2 = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n              fragColor3 = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n              return;\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      primitiveTopology: 'triangle-list',\n      colorStates: colorStateDescriptors,\n      sampleCount: 4,\n    });\n\n    const resolveTargets: GPUTexture[] = [];\n    const renderPassColorAttachmentDescriptors: GPURenderPassColorAttachmentDescriptor[] = [];\n\n    // The resolve target must be the same size as the color attachment. If we're resolving to mip\n    // level 1, the resolve target base mip level should be 2x the color attachment size.\n    const kResolveTargetSize = kSize << t.params.resolveTargetBaseMipLevel;\n\n    for (let i = 0; i < t.params.numColorAttachments; i++) {\n      const colorAttachment = t.device.createTexture({\n        format: kFormat,\n        size: { width: kSize, height: kSize, depth: 1 },\n        sampleCount: 4,\n        mipLevelCount: 1,\n        usage:\n          GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.OUTPUT_ATTACHMENT,\n      });\n\n      if (t.params.slotsToResolve.includes(i)) {\n        const colorAttachment = t.device.createTexture({\n          format: kFormat,\n          size: { width: kSize, height: kSize, depth: 1 },\n          sampleCount: 4,\n          mipLevelCount: 1,\n          usage:\n            GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.OUTPUT_ATTACHMENT,\n        });\n\n        const resolveTarget = t.device.createTexture({\n          format: kFormat,\n          size: {\n            width: kResolveTargetSize,\n            height: kResolveTargetSize,\n            depth: t.params.resolveTargetBaseArrayLayer + 1,\n          },\n          sampleCount: 1,\n          mipLevelCount: t.params.resolveTargetBaseMipLevel + 1,\n          usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.OUTPUT_ATTACHMENT,\n        });\n\n        // Clear to black for the load operation. After the draw, the top left half of the attachment\n        // will be white and the bottom right half will be black.\n        renderPassColorAttachmentDescriptors.push({\n          attachment: colorAttachment.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          storeOp: t.params.storeOperation,\n          resolveTarget: resolveTarget.createView({\n            baseMipLevel: t.params.resolveTargetBaseMipLevel,\n            baseArrayLayer: t.params.resolveTargetBaseArrayLayer,\n          }),\n        });\n\n        resolveTargets.push(resolveTarget);\n      } else {\n        renderPassColorAttachmentDescriptors.push({\n          attachment: colorAttachment.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          storeOp: t.params.storeOperation,\n        });\n      }\n    }\n\n    const encoder = t.device.createCommandEncoder();\n\n    const pass = encoder.beginRenderPass({\n      colorAttachments: renderPassColorAttachmentDescriptors,\n    });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.endPass();\n    t.device.defaultQueue.submit([encoder.finish()]);\n\n    // Verify the resolve targets contain the correct values.\n    for (let i = 0; i < resolveTargets.length; i++) {\n      // Test top left pixel, which should be {255, 255, 255, 255}.\n      t.expectSinglePixelIn2DTexture(\n        resolveTargets[i],\n        kFormat,\n        { x: 0, y: 0 },\n        {\n          exp: new Uint8Array([0xff, 0xff, 0xff, 0xff]),\n          slice: t.params.resolveTargetBaseArrayLayer,\n          layout: { mipLevel: t.params.resolveTargetBaseMipLevel },\n        }\n      );\n\n      // Test bottom right pixel, which should be {0, 0, 0, 0}.\n      t.expectSinglePixelIn2DTexture(\n        resolveTargets[i],\n        kFormat,\n        { x: kSize - 1, y: kSize - 1 },\n        {\n          exp: new Uint8Array([0x00, 0x00, 0x00, 0x00]),\n          slice: t.params.resolveTargetBaseArrayLayer,\n          layout: { mipLevel: t.params.resolveTargetBaseMipLevel },\n        }\n      );\n\n      // Test top right pixel, which should be {127, 127, 127, 127} due to the multisampled resolve.\n      t.expectSinglePixelIn2DTexture(\n        resolveTargets[i],\n        kFormat,\n        { x: kSize - 1, y: 0 },\n        {\n          exp: new Uint8Array([0x7f, 0x7f, 0x7f, 0x7f]),\n          slice: t.params.resolveTargetBaseArrayLayer,\n          layout: { mipLevel: t.params.resolveTargetBaseMipLevel },\n        }\n      );\n    }\n  });\n"],"file":"resolve.spec.js"}
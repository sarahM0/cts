{"version":3,"sources":["../../../../../src/webgpu/api/operation/render_pass/storeop2.spec.ts"],"names":["description","makeTestGroup","GPUTest","g","test","params","storeOp","_expected","fn","t","renderTexture","device","createTexture","size","width","height","depth","format","usage","GPUTextureUsage","COPY_SRC","OUTPUT_ATTACHMENT","renderPipeline","createRenderPipeline","vertexStage","module","createShaderModule","code","entryPoint","fragmentStage","primitiveTopology","colorStates","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","attachment","createView","loadValue","r","b","a","setPipeline","draw","endPass","defaultQueue","submit","finish","expectSingleColor","exp","R"],"mappings":"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","sourcesContent":["export const description = `\nrenderPass store op test that drawn quad is either stored or cleared based on storeop\n\nTODO: is this duplicated with api,operation,render_pass,storeOp?\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('storeOp_controls_whether_1x1_drawn_quad_is_stored')\n  .params([\n    { storeOp: 'store', _expected: 1 }, //\n    { storeOp: 'clear', _expected: 0 },\n  ] as const)\n  .fn(async t => {\n    const renderTexture = t.device.createTexture({\n      size: { width: 1, height: 1, depth: 1 },\n      format: 'r8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.OUTPUT_ATTACHMENT,\n    });\n\n    // create render pipeline\n    const renderPipeline = t.device.createRenderPipeline({\n      vertexStage: {\n        module: t.device.createShaderModule({\n          code: `\n            [[builtin(position)]] var<out> Position : vec4<f32>;\n            [[builtin(vertex_index)]] var<in> VertexIndex : i32;\n\n            [[stage(vertex)]] fn main() -> void {\n              const pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                  vec2<f32>( 1.0, -1.0),\n                  vec2<f32>( 1.0,  1.0),\n                  vec2<f32>(-1.0,  1.0));\n              Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n              return;\n            }\n            `,\n        }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: t.device.createShaderModule({\n          code: `\n            [[location(0)]] var<out> fragColor : vec4<f32>;\n            [[stage(fragment)]] fn main() -> void {\n              fragColor = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n              return;\n            }\n            `,\n        }),\n        entryPoint: 'main',\n      },\n      primitiveTopology: 'triangle-list',\n      colorStates: [{ format: 'r8unorm' }],\n    });\n\n    // encode pass and submit\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          attachment: renderTexture.createView(),\n          storeOp: t.params.storeOp,\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n        },\n      ],\n    });\n    pass.setPipeline(renderPipeline);\n    pass.draw(3);\n    pass.endPass();\n    t.device.defaultQueue.submit([encoder.finish()]);\n\n    // expect the buffer to be clear\n    t.expectSingleColor(renderTexture, 'r8unorm', {\n      size: [1, 1, 1],\n      exp: { R: t.params._expected },\n    });\n  });\n"],"file":"storeop2.spec.js"}
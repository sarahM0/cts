{"version":3,"sources":["../../../src/webgpu/util/device_pool.ts"],"names":["SkipTestCase","assert","raceWithRejectOnTimeout","unreachable","assertReject","DefaultLimits","getGPU","TestFailedButDeviceReusable","Error","TestOOMedShouldAttemptGC","DevicePool","defaultHolder","nonDefaultHolders","DescriptorToHolderMap","reserve","descriptor","DeviceHolder","create","undefined","ex","holder","getOrCreate","state","release","ensureRelease","lostReason","deleteByDevice","device","unsupported","Set","holders","Map","k","v","delete","uncanonicalizedDescriptor","key","canonicalizeDescriptor","has","JSON","stringify","value","get","set","add","message","insertAndCleanUp","kMaxEntries","size","desc","extensionsCanonicalized","extensions","Array","from","sort","limits","limitsCanonicalized","Object","keys","descriptorCanonicalized","gpu","adapter","requestAdapter","requestDevice","constructor","lost","then","ev","acquire","pushErrorScope","kPopErrorScopeTimeoutMS","gpuValidationError","gpuOutOfMemoryError","popErrorScope","GPUValidationError","GPUOutOfMemoryError"],"mappings":"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","sourcesContent":["import { SkipTestCase } from '../../common/framework/fixture.js';\nimport {\n  assert,\n  raceWithRejectOnTimeout,\n  unreachable,\n  assertReject,\n} from '../../common/framework/util/util.js';\nimport { DefaultLimits } from '../constants.js';\n\nimport { getGPU } from './navigator_gpu.js';\n\nexport interface DeviceProvider {\n  acquire(): GPUDevice;\n}\n\nclass TestFailedButDeviceReusable extends Error {}\nexport class TestOOMedShouldAttemptGC extends Error {}\n\nexport class DevicePool {\n  /** Device with no descriptor. */\n  private defaultHolder: DeviceHolder | 'uninitialized' | 'failed' = 'uninitialized';\n  /** Devices with descriptors. */\n  private nonDefaultHolders = new DescriptorToHolderMap();\n\n  /** Request a device from the pool. */\n  async reserve(descriptor?: GPUDeviceDescriptor): Promise<DeviceProvider> {\n    // Always attempt to initialize default device, to see if it succeeds.\n    if (this.defaultHolder === 'uninitialized') {\n      try {\n        this.defaultHolder = await DeviceHolder.create(undefined);\n      } catch (ex) {\n        this.defaultHolder = 'failed';\n      }\n    }\n    assert(this.defaultHolder !== 'failed', 'WebGPU device failed to initialize; not retrying');\n\n    let holder;\n    if (descriptor === undefined) {\n      holder = this.defaultHolder;\n    } else {\n      holder = await this.nonDefaultHolders.getOrCreate(descriptor);\n    }\n\n    assert(holder.state === 'free', 'Device was in use on DevicePool.acquire');\n    holder.state = 'reserved';\n    return holder;\n  }\n\n  // When a test is done using a device, it's released back into the pool.\n  // This waits for error scopes, checks their results, and checks for various error conditions.\n  async release(holder: DeviceProvider): Promise<void> {\n    assert(this.defaultHolder instanceof DeviceHolder);\n    assert(holder instanceof DeviceHolder);\n\n    assert(holder.state !== 'free', 'trying to release a device while already released');\n\n    try {\n      await holder.ensureRelease();\n\n      // (Hopefully if the device was lost, it has been reported by the time endErrorScopes()\n      // has finished (or timed out). If not, it could cause a finite number of extra test\n      // failures following this one (but should recover eventually).)\n      const lostReason = holder.lostReason;\n      if (lostReason !== undefined) {\n        // Fail the current test.\n        unreachable(`Device was lost: ${lostReason}`);\n      }\n    } catch (ex) {\n      // Any error that isn't explicitly TestFailedButDeviceReusable forces a new device to be\n      // created for the next test.\n      if (!(ex instanceof TestFailedButDeviceReusable)) {\n        if (holder === this.defaultHolder) {\n          this.defaultHolder = 'uninitialized';\n        } else {\n          this.nonDefaultHolders.deleteByDevice(holder.device);\n        }\n        // TODO: device.destroy()\n      }\n      throw ex;\n    } finally {\n      // Mark the holder as free. (This only has an effect if the pool still has the holder.)\n      // This could be done at the top but is done here to guard against async-races during release.\n      holder.state = 'free';\n    }\n  }\n}\n\n/**\n * Map from GPUDeviceDescriptor to DeviceHolder.\n */\nclass DescriptorToHolderMap {\n  private unsupported: Set<string> = new Set();\n  private holders: Map<string, DeviceHolder> = new Map();\n\n  /** Deletes an item from the map by GPUDevice value. */\n  deleteByDevice(device: GPUDevice): void {\n    for (const [k, v] of this.holders) {\n      if (v.device === device) {\n        this.holders.delete(k);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Gets a DeviceHolder from the map if it exists; otherwise, calls create() to create one,\n   * inserts it, and returns it.\n   *\n   * Throws SkipTestCase if devices with this descriptor are unsupported.\n   */\n  async getOrCreate(uncanonicalizedDescriptor: GPUDeviceDescriptor): Promise<DeviceHolder> {\n    const [descriptor, key] = canonicalizeDescriptor(uncanonicalizedDescriptor);\n    // Never retry unsupported configurations.\n    if (this.unsupported.has(key)) {\n      throw new SkipTestCase(\n        `GPUDeviceDescriptor previously failed: ${JSON.stringify(descriptor)}`\n      );\n    }\n\n    // Search for an existing device with the same descriptor.\n    {\n      const value = this.holders.get(key);\n      if (value) {\n        // Move it to the end of the Map (most-recently-used).\n        this.holders.delete(key);\n        this.holders.set(key, value);\n        return value;\n      }\n    }\n\n    // No existing item was found; add a new one.\n    let value;\n    try {\n      value = await DeviceHolder.create(descriptor);\n    } catch (ex) {\n      this.unsupported.add(key);\n      throw new SkipTestCase(\n        `GPUDeviceDescriptor not supported: ${JSON.stringify(descriptor)}\\n${ex?.message ?? ''}`\n      );\n    }\n    this.insertAndCleanUp(key, value);\n    return value;\n  }\n\n  /** Insert an entry, then remove the least-recently-used items if there are too many. */\n  private insertAndCleanUp(key: string, value: DeviceHolder) {\n    this.holders.set(key, value);\n\n    const kMaxEntries = 5;\n    if (this.holders.size > kMaxEntries) {\n      // Delete the first (least recently used) item in the set.\n      for (const [key] of this.holders) {\n        this.holders.delete(key);\n        return;\n      }\n    }\n  }\n}\n\ntype CanonicalDeviceDescriptor = Omit<Required<GPUDeviceDescriptor>, 'label'>;\n/**\n * Make a stringified map-key from a GPUDeviceDescriptor.\n * Tries to make sure all defaults are resolved, first - but it's okay if some are missed\n * (it just means some GPUDevice objects won't get deduplicated).\n */\nfunction canonicalizeDescriptor(desc: GPUDeviceDescriptor): [CanonicalDeviceDescriptor, string] {\n  const extensionsCanonicalized = desc.extensions ? Array.from(desc.extensions).sort() : [];\n  const limits: GPULimits = { ...desc.limits };\n\n  const limitsCanonicalized: GPULimits = { ...DefaultLimits };\n  for (const k of Object.keys(limits) as (keyof GPULimits)[]) {\n    if (limits[k] !== undefined) {\n      limitsCanonicalized[k] = limits[k];\n    }\n  }\n\n  // Type ensures every field is carried through.\n  const descriptorCanonicalized: CanonicalDeviceDescriptor = {\n    extensions: extensionsCanonicalized,\n    limits: limitsCanonicalized,\n  };\n  return [descriptorCanonicalized, JSON.stringify(descriptorCanonicalized)];\n}\n\n/**\n * DeviceHolder has three states:\n * - 'free': Free to be used for a new test.\n * - 'reserved': Reserved by a running test, but has not had error scopes created yet.\n * - 'acquired': Reserved by a running test, and has had error scopes created.\n */\ntype DeviceHolderState = 'free' | 'reserved' | 'acquired';\n\n/**\n * Holds a GPUDevice and tracks its state (free/reserved/acquired) and handles device loss.\n */\nclass DeviceHolder implements DeviceProvider {\n  readonly device: GPUDevice;\n  state: DeviceHolderState = 'free';\n  lostReason?: string; // initially undefined; becomes set when the device is lost\n\n  // Gets a device and creates a DeviceHolder.\n  // If the device is lost, DeviceHolder.lostReason gets set.\n  static async create(descriptor: CanonicalDeviceDescriptor | undefined): Promise<DeviceHolder> {\n    const gpu = getGPU();\n    const adapter = await gpu.requestAdapter();\n    assert(adapter !== null, 'requestAdapter returned null');\n    const device = await adapter.requestDevice(descriptor);\n    assert(device !== null, 'requestDevice returned null');\n\n    return new DeviceHolder(device);\n  }\n\n  private constructor(device: GPUDevice) {\n    this.device = device;\n    this.device.lost.then(ev => {\n      this.lostReason = ev.message;\n    });\n  }\n\n  acquire(): GPUDevice {\n    assert(this.state === 'reserved');\n    this.state = 'acquired';\n    this.device.pushErrorScope('out-of-memory');\n    this.device.pushErrorScope('validation');\n    return this.device;\n  }\n\n  async ensureRelease(): Promise<void> {\n    const kPopErrorScopeTimeoutMS = 5000;\n\n    assert(this.state !== 'free');\n    try {\n      if (this.state === 'acquired') {\n        // Time out if popErrorScope never completes. This could happen due to a browser bug - e.g.,\n        // as of this writing, on Chrome GPU process crash, popErrorScope just hangs.\n        await raceWithRejectOnTimeout(\n          this.release(),\n          kPopErrorScopeTimeoutMS,\n          'finalization popErrorScope timed out'\n        );\n      }\n    } finally {\n      this.state = 'free';\n    }\n  }\n\n  private async release(): Promise<void> {\n    // End the whole-test error scopes. Check that there are no extra error scopes, and that no\n    // otherwise-uncaptured errors occurred during the test.\n    let gpuValidationError: GPUValidationError | GPUOutOfMemoryError | null;\n    let gpuOutOfMemoryError: GPUValidationError | GPUOutOfMemoryError | null;\n\n    try {\n      // May reject if the device was lost.\n      gpuValidationError = await this.device.popErrorScope();\n      gpuOutOfMemoryError = await this.device.popErrorScope();\n    } catch (ex) {\n      assert(\n        this.lostReason !== undefined,\n        'popErrorScope failed; should only happen if device has been lost'\n      );\n      throw ex;\n    }\n\n    await assertReject(\n      this.device.popErrorScope(),\n      'There was an extra error scope on the stack after a test'\n    );\n\n    if (gpuValidationError !== null) {\n      assert(gpuValidationError instanceof GPUValidationError);\n      // Allow the device to be reused.\n      throw new TestFailedButDeviceReusable(\n        `Unexpected validation error occurred: ${gpuValidationError.message}`\n      );\n    }\n    if (gpuOutOfMemoryError !== null) {\n      assert(gpuOutOfMemoryError instanceof GPUOutOfMemoryError);\n      // Don't allow the device to be reused; unexpected OOM could break the device.\n      throw new TestOOMedShouldAttemptGC('Unexpected out-of-memory error occurred');\n    }\n  }\n}\n"],"file":"device_pool.js"}